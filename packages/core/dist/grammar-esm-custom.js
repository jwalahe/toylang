// Generated grammar converted to ES modules
import lexer from './lexer';
function id(x) { return x[0]; }
const grammar = {
    Lexer: lexer,
    ParserStart: "Program",
    ParserRules: [
        { "name": "Program$ebnf$1", "symbols": [] },
        { "name": "Program$ebnf$1", "symbols": ["Program$ebnf$1", "Statement"], "postprocess": function arrpush(d) { return d[0].concat([d[1]]); } },
        { "name": "Program", "symbols": ["_", "Program$ebnf$1", "_"], "postprocess": ([, statements]) => ({ type: 'Program', body: statements.filter((s) => s !== null) }) },
        { "name": "Statement", "symbols": ["PrintStatement"], "postprocess": id },
        { "name": "Statement", "symbols": ["VarDeclaration"], "postprocess": id },
        { "name": "Statement", "symbols": ["IfStatement"], "postprocess": id },
        { "name": "Statement", "symbols": ["LoopStatement"], "postprocess": id },
        { "name": "Statement", "symbols": ["BlockStatement"], "postprocess": id },
        { "name": "Statement", "symbols": ["FunctionDecl"], "postprocess": id },
        { "name": "Statement", "symbols": ["ReturnStatement"], "postprocess": id },
        { "name": "Statement", "symbols": ["ExprStatement"], "postprocess": id },
        { "name": "PrintStatement", "symbols": ["yeet", "_", "Expression", "_", "semicolon"], "postprocess": ([, , expr]) => ({ type: 'PrintStatement', expression: expr }) },
        { "name": "VarDeclaration", "symbols": ["tea", "_", "identifier", "_", "assign", "_", "Expression", "_", "semicolon"], "postprocess": ([, , name, , , , value]) => ({ type: 'VarDeclaration', name: name.value, value }) },
        { "name": "IfStatement", "symbols": ["sus", "_", "lparen", "_", "Expression", "_", "rparen", "_", "Statement"], "postprocess": ([, , , , condition, , , , then]) => ({ type: 'IfStatement', condition, then, else: null }) },
        { "name": "IfStatement", "symbols": ["sus", "_", "lparen", "_", "Expression", "_", "rparen", "_", "Statement", "_", "cap", "_", "Statement"], "postprocess": ([, , , , condition, , , , then, , , , else_]) => ({ type: 'IfStatement', condition, then, else: else_ }) },
        { "name": "LoopStatement", "symbols": ["vibe", "_", "lparen", "_", "Expression", "_", "rparen", "_", "Statement"], "postprocess": ([, , , , condition, , , , body]) => ({ type: 'LoopStatement', condition, body }) },
        { "name": "BlockStatement", "symbols": ["lbrace", "_", "BlockStatements", "_", "rbrace"], "postprocess": ([, , statements]) => ({ type: 'BlockStatement', body: statements }) },
        { "name": "BlockStatements$ebnf$1", "symbols": [] },
        { "name": "BlockStatements$ebnf$1", "symbols": ["BlockStatements$ebnf$1", "Statement"], "postprocess": function arrpush(d) { return d[0].concat([d[1]]); } },
        { "name": "BlockStatements", "symbols": ["_", "BlockStatements$ebnf$1", "_"], "postprocess": ([, statements]) => statements.filter((s) => s !== null) },
        { "name": "FunctionDecl", "symbols": ["lowkey", "_", "identifier", "_", "lparen", "_", "Parameters", "_", "rparen", "_", "Statement"], "postprocess": ([, , name, , , , params, , , , body]) => ({ type: 'FunctionDecl', name: name.value, params, body }) },
        { "name": "Parameters$ebnf$1", "symbols": [] },
        { "name": "Parameters$ebnf$1", "symbols": ["Parameters$ebnf$1", "ParameterTail"], "postprocess": function arrpush(d) { return d[0].concat([d[1]]); } },
        { "name": "Parameters", "symbols": ["identifier", "Parameters$ebnf$1"], "postprocess": ([first, rest]) => [first.value, ...rest] },
        { "name": "Parameters", "symbols": [], "postprocess": () => [] },
        { "name": "ParameterTail", "symbols": ["_", "comma", "_", "identifier"], "postprocess": ([, , , param]) => param.value },
        { "name": "ReturnStatement", "symbols": ["fr", "_", "Expression", "_", "semicolon"], "postprocess": ([, , expr]) => ({ type: 'ReturnStatement', expression: expr }) },
        { "name": "ExprStatement", "symbols": ["Expression", "_", "semicolon"], "postprocess": ([expr]) => ({ type: 'ExprStatement', expression: expr }) },
        { "name": "Expression", "symbols": ["Assignment"], "postprocess": id },
        { "name": "Expression", "symbols": ["BinaryExpression"], "postprocess": id },
        { "name": "Assignment", "symbols": ["identifier", "_", "assign", "_", "Expression"], "postprocess": (data) => {
                const id = data[0];
                const expr = data[4];
                return {
                    type: 'BinaryExpression',
                    operator: 'assign',
                    left: { type: 'Identifier', name: id.value },
                    right: expr
                };
            }
        },
        { "name": "BinaryExpression", "symbols": ["ComparisonExpression"], "postprocess": id },
        { "name": "ComparisonExpression", "symbols": ["ArithmeticExpression"], "postprocess": id },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "eq", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '==', left, right }) },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "neq", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '!=', left, right }) },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "lt", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '<', left, right }) },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "gt", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '>', left, right }) },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "lteq", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '<=', left, right }) },
        { "name": "ComparisonExpression", "symbols": ["ComparisonExpression", "_", "gteq", "_", "ArithmeticExpression"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '>=', left, right }) },
        { "name": "ArithmeticExpression", "symbols": ["Term"], "postprocess": id },
        { "name": "ArithmeticExpression", "symbols": ["ArithmeticExpression", "_", "bop", "_", "Term"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '+', left, right }) },
        { "name": "ArithmeticExpression", "symbols": ["ArithmeticExpression", "_", "skrt", "_", "Term"], "postprocess": ([left, , , , right]) => ({ type: 'BinaryExpression', operator: '-', left, right }) },
        { "name": "Term", "symbols": ["Factor"], "postprocess": id },
        { "name": "Factor", "symbols": ["PrimaryExpression"], "postprocess": id },
        { "name": "PrimaryExpression", "symbols": ["number"], "postprocess": ([token]) => ({ type: 'NumberLiteral', value: parseFloat(token.value) }) },
        { "name": "PrimaryExpression", "symbols": ["string"], "postprocess": ([token]) => ({ type: 'StringLiteral', value: token.value.slice(1, -1) }) },
        { "name": "PrimaryExpression", "symbols": ["bet"], "postprocess": () => ({ type: 'BooleanLiteral', value: true }) },
        { "name": "PrimaryExpression", "symbols": ["cap"], "postprocess": () => ({ type: 'BooleanLiteral', value: false }) },
        { "name": "PrimaryExpression", "symbols": ["identifier"], "postprocess": ([token]) => ({ type: 'Identifier', name: token.value }) },
        { "name": "PrimaryExpression", "symbols": ["FunctionCall"], "postprocess": id },
        { "name": "PrimaryExpression", "symbols": ["lparen", "_", "Expression", "_", "rparen"], "postprocess": ([, , expr]) => expr },
        { "name": "FunctionCall", "symbols": ["identifier", "_", "lparen", "_", "Arguments", "_", "rparen"], "postprocess": ([name, , , , args]) => ({ type: 'FunctionCall', name: name.value, args }) },
        { "name": "Arguments$ebnf$1", "symbols": [] },
        { "name": "Arguments$ebnf$1", "symbols": ["Arguments$ebnf$1", "ArgumentTail"], "postprocess": function arrpush(d) { return d[0].concat([d[1]]); } },
        { "name": "Arguments", "symbols": ["Expression", "Arguments$ebnf$1"], "postprocess": ([first, rest]) => [first, ...rest] },
        { "name": "Arguments", "symbols": [], "postprocess": () => [] },
        { "name": "ArgumentTail", "symbols": ["_", "comma", "_", "Expression"], "postprocess": ([, , , arg]) => arg },
        { "name": "_$ebnf$1", "symbols": [] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": function arrpush(d) { return d[0].concat([d[1]]); } },
        { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function (d) { return null; } },
        { "name": "wschar", "symbols": [/[ \t\n\r]/], "postprocess": function (d) { return null; } },
        { "name": "yeet", "symbols": [lexer.has("yeet") ? { type: "yeet" } : "yeet"], "postprocess": id },
        { "name": "sus", "symbols": [lexer.has("sus") ? { type: "sus" } : "sus"], "postprocess": id },
        { "name": "bet", "symbols": [lexer.has("bet") ? { type: "bet" } : "bet"], "postprocess": id },
        { "name": "cap", "symbols": [lexer.has("cap") ? { type: "cap" } : "cap"], "postprocess": id },
        { "name": "tea", "symbols": [lexer.has("tea") ? { type: "tea" } : "tea"], "postprocess": id },
        { "name": "lowkey", "symbols": [lexer.has("lowkey") ? { type: "lowkey" } : "lowkey"], "postprocess": id },
        { "name": "vibe", "symbols": [lexer.has("vibe") ? { type: "vibe" } : "vibe"], "postprocess": id },
        { "name": "fr", "symbols": [lexer.has("fr") ? { type: "fr" } : "fr"], "postprocess": id },
        { "name": "bop", "symbols": [lexer.has("bop") ? { type: "bop" } : "bop"], "postprocess": id },
        { "name": "skrt", "symbols": [lexer.has("skrt") ? { type: "skrt" } : "skrt"], "postprocess": id },
        { "name": "lparen", "symbols": [lexer.has("lparen") ? { type: "lparen" } : "lparen"], "postprocess": id },
        { "name": "rparen", "symbols": [lexer.has("rparen") ? { type: "rparen" } : "rparen"], "postprocess": id },
        { "name": "lbrace", "symbols": [lexer.has("lbrace") ? { type: "lbrace" } : "lbrace"], "postprocess": id },
        { "name": "rbrace", "symbols": [lexer.has("rbrace") ? { type: "rbrace" } : "rbrace"], "postprocess": id },
        { "name": "semicolon", "symbols": [lexer.has("semicolon") ? { type: "semicolon" } : "semicolon"], "postprocess": id },
        { "name": "comma", "symbols": [lexer.has("comma") ? { type: "comma" } : "comma"], "postprocess": id },
        { "name": "assign", "symbols": [lexer.has("assign") ? { type: "assign" } : "assign"], "postprocess": id },
        { "name": "eq", "symbols": [lexer.has("eq") ? { type: "eq" } : "eq"], "postprocess": id },
        { "name": "neq", "symbols": [lexer.has("neq") ? { type: "neq" } : "neq"], "postprocess": id },
        { "name": "lt", "symbols": [lexer.has("lt") ? { type: "lt" } : "lt"], "postprocess": id },
        { "name": "gt", "symbols": [lexer.has("gt") ? { type: "gt" } : "gt"], "postprocess": id },
        { "name": "lteq", "symbols": [lexer.has("lteq") ? { type: "lteq" } : "lteq"], "postprocess": id },
        { "name": "gteq", "symbols": [lexer.has("gteq") ? { type: "gteq" } : "gteq"], "postprocess": id },
        { "name": "number", "symbols": [lexer.has("number") ? { type: "number" } : "number"], "postprocess": id },
        { "name": "string", "symbols": [lexer.has("string") ? { type: "string" } : "string"], "postprocess": id },
        { "name": "identifier", "symbols": [lexer.has("identifier") ? { type: "identifier" } : "identifier"], "postprocess": id }
    ]
};
export default grammar;
//# sourceMappingURL=grammar-esm-custom.js.map